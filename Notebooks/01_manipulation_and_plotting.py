# -*- coding: utf-8 -*-
"""01_Manipulation and Plotting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n5_rrlEXseRuVFNkGJoUhxNtUVzNduja

## **Manipulating and Viewing .fits files**

### **Bibliotecas**
"""

# Para manipulação dos arquivos .fits
from astropy.io import fits

# Para manipulação dos dados obtidos pelos arquivos .fits
import numpy as np

# Para utilizar funções de DataFrame
import pandas as pd

# Para plotar o gráfico da Curva de Luz
import plotly.express as px

"""Primeiramente, precisamos importar o arquivo .fits

E logo, podemos ver que ele é do tipo HDUList
"""

image_file = fits.open('/content/drive/MyDrive/00_IC/dataset_exoplanets_confirmed/EN2_STAR_CHR_0101086161_20070516T060226_20071005T074409.fits')
print(type(image_file))

"""Os arquivos .fits possuem diversas extensões, como podemos ver pelo *len(image_file)*, nosso arquivo possui 4 extensões. 
Nos interessa apenas a 3º extensão visto que ela apresenta apenas os dados do DATEBARRT e do WHITEFLUXSYS.

"""

len(image_file)

"""Dessa forma, obtemos os dados contidos na extesão 3 do arquivo .fits e observamos que são do tipo FITS_rec."""

scidata = image_file[3].data
print(type(scidata))

print("\n")
scidata

"""Para manipulação do *scidata*, opta-se por transforma-lo em array, utilizando a biblioteca *NumPy*

Nesse ponto, chegamos a um problema que vale a pena ser comentado.

O arquivo original, quando transformado para array, segundo o código:
```
# x = np.array(scidata)
```
apresenta o seguinte erro ao ser plotado futuramente, utilizando a biblioteca *Plotly*: 

**ValueError: Big-endian buffer not supported on little-endian compiler**

Esse erro ocorre quando os dados que estão sendo trabalhados foram criados em uma máquina com uma ordem de bits diferente da que está executando o *Python*. 
Para lidar com esse problema, devemos converter a matriz NumPy para a ordem de bits do sistema nativo antes de tranformá-la em um DataFrame ou uma Series.

Assim, utiliza-se os métodos *byteswap()* e *newbyteorder*().

Referência: https://pandas.pydata.org/pandas-docs/stable/user_guide/gotchas.html#byte-ordering-issues
"""

x = np.array(scidata).byteswap().newbyteorder()

"""Com os dados normalizados, os transformamos em DataFrame e em seguida separamos a parte que nos interessa, ou seja, apenas as colunas DATABARRT e WHITEFLUXSYS."""

data = pd.DataFrame(x)

data.head()

data = data[['DATEBARTT', 'WHITEFLUXSYS']]

data.head()

"""### **Plotando a Curva de Luz**

Plota-se a série temporal utilizando o *Plotly* como um gráfico de linha.
"""

fig = px.line(data, x='DATEBARTT', y='WHITEFLUXSYS', title='Light Curve')
fig.show()

"""### **Salvando dados pré-processados**

Por fim, salvamos os dados obtidos no .fits como .csv e .txt, visando facilitar as futuras operações.
"""

# Salvando com .csv
data.to_csv('data_exo.csv')

# Salvando como .txt
import csv

csv_file = '/content/data_exo.csv'
txt_file = 'data_exo.txt'

with open(txt_file, "w") as output_file:
  with open(csv_file, "r") as input_file:
    [ output_file.write(" ".join(row)+'\n') for row in csv.reader(input_file) ]
  output_file.close()